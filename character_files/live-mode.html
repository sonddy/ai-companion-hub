<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Companion - TikTok Live Mode</title>
  
  <!-- Import maps for ES modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js"
    }
  }
  </script>
  
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --nicky-accent: #ff6b9d;
      --luna-accent: #ffb366;
      --oracle-accent: #a366ff;
      --text: #ffffff;
      --bg-nicky: radial-gradient(ellipse at center, #1a0a15 0%, #0a0510 50%, #050208 100%);
      --bg-luna: radial-gradient(ellipse at center, #1a150a 0%, #0a0805 50%, #080502 100%);
      --bg-oracle: radial-gradient(ellipse at center, #150a1a 0%, #08050a 50%, #020108 100%);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Poppins', sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }
    
    body.nicky { background: var(--bg-nicky); --accent: var(--nicky-accent); }
    body.luna { background: var(--bg-luna); --accent: var(--luna-accent); }
    body.oracle { background: var(--bg-oracle); --accent: var(--oracle-accent); }
    body.greenscreen { background: #00ff00 !important; }
    
    #app {
      width: 100%;
      height: 100%;
      display: flex;
      position: relative;
    }
    
    #canvas-container {
      flex: 1;
      position: relative;
    }
    
    #canvas-container canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    /* Character name overlay */
    .character-name {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 32px;
      font-weight: 800;
      color: var(--accent);
      text-shadow: 0 0 30px var(--accent), 0 4px 20px rgba(0,0,0,0.8);
      z-index: 50;
      opacity: 0.9;
    }
    
    /* Question display overlay */
    .question-overlay {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      max-width: 800px;
      width: 90%;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid var(--accent);
      border-radius: 20px;
      padding: 20px 30px;
      z-index: 100;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 40px rgba(0,0,0,0.5), 0 0 20px var(--accent);
      transition: all 0.5s ease;
      opacity: 0;
      transform: translateX(-50%) translateY(-20px);
    }
    
    .question-overlay.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    
    .question-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    
    .question-icon {
      font-size: 24px;
    }
    
    .viewer-name {
      font-size: 18px;
      font-weight: 700;
      color: var(--accent);
    }
    
    .question-text {
      font-size: 22px;
      font-weight: 600;
      color: var(--text);
      line-height: 1.4;
    }
    
    /* Response display */
    .response-overlay {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      max-width: 900px;
      width: 90%;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid var(--accent);
      border-radius: 20px;
      padding: 25px 35px;
      z-index: 100;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 40px rgba(0,0,0,0.5), 0 0 20px var(--accent);
      transition: all 0.5s ease;
      opacity: 0;
      transform: translateX(-50%) translateY(20px);
    }
    
    .response-overlay.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    
    .response-text {
      font-size: 24px;
      font-weight: 500;
      color: var(--text);
      line-height: 1.5;
      text-align: center;
    }
    
    /* Control panel */
    .control-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 15px;
      padding: 20px;
      z-index: 200;
      min-width: 280px;
    }
    
    .control-panel.hidden {
      display: none;
    }
    
    .control-panel h3 {
      font-size: 16px;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 15px;
      text-align: center;
    }
    
    .control-group {
      margin-bottom: 15px;
    }
    
    .control-group label {
      display: block;
      font-size: 12px;
      color: rgba(255,255,255,0.7);
      margin-bottom: 6px;
    }
    
    .control-group input, .control-group select {
      width: 100%;
      padding: 10px 12px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: white;
      font-size: 14px;
    }
    
    .control-group select option {
      background: #1a1a2e;
    }
    
    .btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 10px;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--accent), rgba(255,255,255,0.2));
      color: white;
    }
    
    .btn-primary:hover {
      transform: scale(1.02);
      box-shadow: 0 0 20px var(--accent);
    }
    
    .btn-secondary {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
    }
    
    .btn-secondary:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .btn-danger {
      background: rgba(255, 80, 80, 0.3);
      border: 1px solid rgba(255, 80, 80, 0.5);
      color: #ff8080;
    }
    
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: rgba(255,255,255,0.8);
      margin-bottom: 15px;
    }
    
    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff5555;
    }
    
    .status-dot.connected {
      background: #55ff55;
      animation: pulse-green 2s infinite;
    }
    
    @keyframes pulse-green {
      0%, 100% { box-shadow: 0 0 5px #55ff55; }
      50% { box-shadow: 0 0 15px #55ff55; }
    }
    
    .queue-info {
      font-size: 13px;
      color: rgba(255,255,255,0.6);
      text-align: center;
      margin-top: 10px;
    }
    
    /* Toggle control panel button */
    .toggle-controls {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(0,0,0,0.8);
      border: 1px solid var(--accent);
      border-radius: 50%;
      color: var(--accent);
      font-size: 24px;
      cursor: pointer;
      z-index: 201;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .toggle-controls.panel-visible {
      display: none;
    }
    
    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 20;
    }
    
    .loading-overlay.hidden { display: none; }
    
    .loading-text {
      color: var(--accent);
      font-size: 20px;
      font-weight: 600;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    /* Auto mode indicator */
    .auto-mode-indicator {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      border: 1px solid var(--accent);
      border-radius: 10px;
      padding: 10px 20px;
      z-index: 100;
      display: none;
    }
    
    .auto-mode-indicator.active {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .auto-mode-indicator .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff5555;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    
    .auto-mode-indicator span {
      color: white;
      font-size: 14px;
      font-weight: 600;
    }
  </style>
</head>

<body class="nicky">
  <div id="app">
    <div id="canvas-container">
      <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-text">Loading 3D Model...</div>
      </div>
    </div>
  </div>
  
  <!-- Character name -->
  <div class="character-name" id="characterName">NICKY</div>
  
  <!-- Question overlay -->
  <div class="question-overlay" id="questionOverlay">
    <div class="question-header">
      <span class="question-icon">üí¨</span>
      <span class="viewer-name" id="viewerName">@viewer</span>
    </div>
    <div class="question-text" id="questionText">Question goes here...</div>
  </div>
  
  <!-- Response overlay -->
  <div class="response-overlay" id="responseOverlay">
    <div class="response-text" id="responseText">Response goes here...</div>
  </div>
  
  <!-- Auto mode indicator -->
  <div class="auto-mode-indicator" id="autoModeIndicator">
    <div class="dot"></div>
    <span>LIVE - AUTO MODE</span>
  </div>
  
  <!-- Toggle button -->
  <button class="toggle-controls" id="toggleControls" onclick="toggleControlPanel()">‚öôÔ∏è</button>
  
  <!-- Control Panel -->
  <div class="control-panel" id="controlPanel">
    <h3>üé¨ TikTok Live Controls</h3>
    
    <div class="status-indicator">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Disconnected</span>
    </div>
    
    <div class="control-group">
      <label>Character</label>
      <select id="characterSelect" onchange="switchCharacter()">
        <option value="nicky">Nicky - Flirty & Playful</option>
        <option value="luna">Luna - Warm & Supportive</option>
        <option value="oracle">Oracle - Mystical & Wise</option>
      </select>
    </div>
    
    <div class="control-group">
      <label>TikTok Username</label>
      <input type="text" id="tiktokUsername" placeholder="@username" />
    </div>
    
    <button class="btn btn-primary" id="connectBtn" onclick="connectToStream()">
      üîó Connect to Stream
    </button>
    
    <button class="btn btn-secondary" onclick="pickNextQuestion()">
      üé≤ Pick Random Question
    </button>
    
    <button class="btn btn-secondary" id="autoModeBtn" onclick="toggleAutoMode()">
      üîÑ Start Auto Mode
    </button>
    
    <div class="control-group">
      <label>Simulate Question (Testing)</label>
      <input type="text" id="testUsername" placeholder="Viewer name" />
      <input type="text" id="testQuestion" placeholder="Test question..." style="margin-top: 6px;" />
    </div>
    
    <button class="btn btn-secondary" onclick="addTestQuestion()">
      ‚ûï Add Test Question
    </button>
    
    <div class="control-group" style="margin-top: 15px;">
      <label>Background</label>
      <select id="bgSelect" onchange="changeBackground()">
        <option value="normal">Normal Background</option>
        <option value="greenscreen">Green Screen (OBS)</option>
      </select>
    </div>
    
    <button class="btn btn-danger" onclick="hideControlPanel()">
      ‚úñ Hide Controls (Press H to show)
    </button>
    
    <div class="queue-info" id="queueInfo">
      Questions in queue: 0
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

    // API endpoints
    const TIKTOK_API = '/.netlify/functions/tiktok-live';
    const LOCAL_TIKTOK_API = 'http://127.0.0.1:8020';
    
    // Use local API for development, Netlify for production
    const API_BASE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      ? LOCAL_TIKTOK_API
      : TIKTOK_API;

    // Character models
    const CHARACTER_MODELS = {
      nicky: 'models/nicky.vrm',
      luna: 'models/luna.vrm',
      oracle: 'models/oracle.vrm'
    };

    let currentCharacter = 'nicky';
    let scene, camera, renderer, controls;
    let vrm = null;
    let clock = new THREE.Clock();
    let isTalking = false;
    let isAutoMode = false;
    let autoModeInterval = null;
    let currentAudio = null;

    // Animation state
    let blinkTimer = 0;
    let isBlinking = false;
    let breathTimer = 0;
    let bodySwayTimer = 0;

    // Initialize scene
    function init() {
      const container = document.getElementById('canvas-container');
      
      scene = new THREE.Scene();
      
      camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.2, 3);
      camera.lookAt(0, 1, 0);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      container.appendChild(renderer.domElement);
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
      mainLight.position.set(2, 3, 2);
      scene.add(mainLight);
      
      const fillLight = new THREE.DirectionalLight(0x8888ff, 0.4);
      fillLight.position.set(-2, 1, -1);
      scene.add(fillLight);
      
      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1.0, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxDistance = 8;
      controls.minDistance = 1.5;
      controls.update();
      
      loadVRM(CHARACTER_MODELS[currentCharacter]);
      animate();
      
      window.addEventListener('resize', onResize);
      document.addEventListener('keydown', onKeyDown);
    }

    function loadVRM(modelPath) {
      document.getElementById('loadingOverlay').classList.remove('hidden');
      
      if (vrm) {
        scene.remove(vrm.scene);
        VRMUtils.deepDispose(vrm.scene);
        vrm = null;
      }
      
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMLoaderPlugin(parser));
      
      loader.load(
        modelPath,
        (gltf) => {
          vrm = gltf.userData.vrm;
          VRMUtils.removeUnnecessaryJoints(vrm.scene);
          VRMUtils.removeUnnecessaryVertices(vrm.scene);
          VRMUtils.rotateVRM0(vrm);
          
          vrm.scene.traverse((obj) => {
            if (obj.isMesh) {
              obj.frustumCulled = false;
            }
          });
          
          scene.add(vrm.scene);
          document.getElementById('loadingOverlay').classList.add('hidden');
        },
        (progress) => {
          const percent = Math.round((progress.loaded / progress.total) * 100);
          document.querySelector('.loading-text').textContent = `Loading... ${percent}%`;
        },
        (error) => {
          console.error('Error loading VRM:', error);
          document.querySelector('.loading-text').textContent = 'Error loading model';
        }
      );
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      
      if (vrm) {
        updateExpressions(delta);
        updateBodyMovement(delta);
        vrm.update(delta);
      }
      
      controls.update();
      renderer.render(scene, camera);
    }

    function updateExpressions(delta) {
      if (!vrm || !vrm.expressionManager) return;
      
      // Blinking
      blinkTimer += delta;
      if (!isBlinking && blinkTimer > 3 + Math.random() * 4) {
        isBlinking = true;
        blinkTimer = 0;
      }
      
      if (isBlinking) {
        const blinkProgress = blinkTimer / 0.15;
        if (blinkProgress < 1) {
          vrm.expressionManager.setValue('blink', Math.sin(blinkProgress * Math.PI));
        } else {
          vrm.expressionManager.setValue('blink', 0);
          isBlinking = false;
          blinkTimer = 0;
        }
      }
      
      // Talking animation
      if (isTalking) {
        const talkValue = 0.3 + Math.sin(Date.now() * 0.015) * 0.2 + Math.sin(Date.now() * 0.023) * 0.15;
        vrm.expressionManager.setValue('aa', Math.max(0, Math.min(1, talkValue)));
        vrm.expressionManager.setValue('happy', 0.3);
      } else {
        vrm.expressionManager.setValue('aa', 0);
        vrm.expressionManager.setValue('happy', 0.1);
      }
    }

    function updateBodyMovement(delta) {
      if (!vrm) return;
      
      breathTimer += delta;
      bodySwayTimer += delta;
      
      const spine = vrm.humanoid?.getNormalizedBoneNode('spine');
      const chest = vrm.humanoid?.getNormalizedBoneNode('chest');
      const head = vrm.humanoid?.getNormalizedBoneNode('head');
      
      // Breathing
      const breathAmount = Math.sin(breathTimer * 1.5) * 0.008;
      if (chest) {
        chest.rotation.x = breathAmount;
      }
      
      // Body sway
      const swayX = Math.sin(bodySwayTimer * 0.5) * 0.02;
      const swayZ = Math.cos(bodySwayTimer * 0.3) * 0.01;
      if (spine) {
        spine.rotation.z = swayX;
        spine.rotation.x = swayZ;
      }
      
      // Enhanced movement when talking
      if (isTalking) {
        const talkSway = Math.sin(bodySwayTimer * 2) * 0.03;
        if (head) {
          head.rotation.y = talkSway;
          head.rotation.x = Math.sin(bodySwayTimer * 1.5) * 0.02;
        }
        if (spine) {
          spine.rotation.z += Math.sin(bodySwayTimer * 1.8) * 0.015;
        }
      }
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(e) {
      if (e.key === 'h' || e.key === 'H') {
        toggleControlPanel();
      }
    }

    // Expose functions to global scope
    window.switchCharacter = function() {
      const select = document.getElementById('characterSelect');
      currentCharacter = select.value;
      
      document.body.className = currentCharacter;
      if (document.getElementById('bgSelect').value === 'greenscreen') {
        document.body.classList.add('greenscreen');
      }
      
      document.getElementById('characterName').textContent = currentCharacter.toUpperCase();
      loadVRM(CHARACTER_MODELS[currentCharacter]);
    };

    window.toggleControlPanel = function() {
      const panel = document.getElementById('controlPanel');
      const toggle = document.getElementById('toggleControls');
      
      if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        toggle.classList.add('panel-visible');
      } else {
        panel.classList.add('hidden');
        toggle.classList.remove('panel-visible');
      }
    };

    window.hideControlPanel = function() {
      document.getElementById('controlPanel').classList.add('hidden');
      document.getElementById('toggleControls').classList.remove('panel-visible');
    };

    window.changeBackground = function() {
      const bg = document.getElementById('bgSelect').value;
      document.body.classList.remove('greenscreen');
      if (bg === 'greenscreen') {
        document.body.classList.add('greenscreen');
      }
    };

    window.connectToStream = async function() {
      const username = document.getElementById('tiktokUsername').value.replace('@', '');
      if (!username) {
        alert('Please enter a TikTok username');
        return;
      }
      
      try {
        const response = await fetch(`${API_BASE}/connect`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username })
        });
        
        const data = await response.json();
        
        if (data.status === 'connected_simulation' || data.status === 'connecting') {
          document.getElementById('statusDot').classList.add('connected');
          document.getElementById('statusText').textContent = 'Connected';
          document.getElementById('connectBtn').textContent = '‚úÖ Connected';
        }
        
        updateQueueInfo();
      } catch (error) {
        console.error('Connection error:', error);
        alert('Failed to connect. Make sure the TikTok Live service is running.');
      }
    };

    window.addTestQuestion = async function() {
      const username = document.getElementById('testUsername').value || 'TestViewer';
      const question = document.getElementById('testQuestion').value;
      
      if (!question) {
        alert('Please enter a test question');
        return;
      }
      
      try {
        await fetch(`${API_BASE}/add-question`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, question })
        });
        
        document.getElementById('testQuestion').value = '';
        updateQueueInfo();
      } catch (error) {
        console.error('Error adding question:', error);
      }
    };

    window.pickNextQuestion = async function() {
      try {
        const response = await fetch(`${API_BASE}/pick-question`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ character: currentCharacter })
        });
        
        if (response.status === 404) {
          console.log('No questions in queue');
          hideOverlays();
          return false;
        }
        
        if (!response.ok) {
          throw new Error('Failed to get response');
        }
        
        // Get metadata from headers
        const responseText = decodeURIComponent(response.headers.get('X-Response-Text') || '');
        const questionText = decodeURIComponent(response.headers.get('X-Question-Text') || '');
        const viewerUsername = decodeURIComponent(response.headers.get('X-Viewer-Username') || 'Viewer');
        
        // Show question overlay
        document.getElementById('viewerName').textContent = `@${viewerUsername}`;
        document.getElementById('questionText').textContent = questionText;
        document.getElementById('questionOverlay').classList.add('visible');
        
        // Show response overlay
        document.getElementById('responseText').textContent = responseText;
        document.getElementById('responseOverlay').classList.add('visible');
        
        // Play audio
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        
        if (currentAudio) {
          currentAudio.pause();
          currentAudio = null;
        }
        
        currentAudio = new Audio(audioUrl);
        isTalking = true;
        
        currentAudio.onended = () => {
          isTalking = false;
          URL.revokeObjectURL(audioUrl);
          
          // Hide overlays after a delay
          setTimeout(() => {
            hideOverlays();
          }, 2000);
        };
        
        currentAudio.play();
        updateQueueInfo();
        return true;
        
      } catch (error) {
        console.error('Error picking question:', error);
        return false;
      }
    };

    function hideOverlays() {
      document.getElementById('questionOverlay').classList.remove('visible');
      document.getElementById('responseOverlay').classList.remove('visible');
    }

    async function updateQueueInfo() {
      try {
        const response = await fetch(`${API_BASE}/questions`);
        const data = await response.json();
        document.getElementById('queueInfo').textContent = `Questions in queue: ${data.count}`;
      } catch (error) {
        console.error('Error updating queue info:', error);
      }
    }

    window.toggleAutoMode = function() {
      isAutoMode = !isAutoMode;
      const btn = document.getElementById('autoModeBtn');
      const indicator = document.getElementById('autoModeIndicator');
      
      if (isAutoMode) {
        btn.textContent = '‚èπ Stop Auto Mode';
        indicator.classList.add('active');
        runAutoMode();
      } else {
        btn.textContent = 'üîÑ Start Auto Mode';
        indicator.classList.remove('active');
        if (autoModeInterval) {
          clearTimeout(autoModeInterval);
          autoModeInterval = null;
        }
      }
    };

    async function runAutoMode() {
      if (!isAutoMode) return;
      
      const hasQuestion = await window.pickNextQuestion();
      
      // Wait for current audio to finish, then check for next question
      const delay = hasQuestion ? 8000 : 5000; // Longer delay if we just played something
      
      autoModeInterval = setTimeout(() => {
        runAutoMode();
      }, delay);
    }

    // Initialize
    init();
    
    // Periodically update queue info
    setInterval(updateQueueInfo, 5000);
  </script>
</body>
</html>

